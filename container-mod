#!/bin/bash

# Yucheng Zhang

# Copyright (c) 2024 Tufts University
# This script is modified from the original script written by Lev Gorenstein from Purdue University.
# The original script is available at (https://github.com/PurdueRCAC/Biocontainers).

# This script assumes that you have Singularity or Apptainer
# installed on your system.
#
# Usage: Run "container-mod --help" for instructions.
VERSION="0.1.5" # Increment this version for updates

E_OK=0
PROGNAME="$(basename "$0")"

###############################################################################
# Prerequisites: Ensure Singularity or Apptainer is available
###############################################################################

if ! command -v singularity &>/dev/null && ! module load singularity &>/dev/null && ! module load apptainer &>/dev/null;
then
    echo "Failed to load both Singularity and Apptainer modules."
    exit 1
fi

###############################################################################
# Helper functions
###############################################################################

# --- Caches for app name and version to avoid repeated prompting ---
declare -A APP_CACHE
declare -A VER_CACHE

clean_up() {
	# Perform pre-exit housekeeping
	return
}

# Function to print a message and exit with a status
graceful_exit() {
	# graceful_exit [status]]
	clean_up
	exit ${1:-$E_OK}
}

# Function to send warning messages to stderr.
warn() {
    # warn [-p] "message" ["message"...]
    # Sends message(s) to stderr, optionally prefixing with "PROGNAME: ".
    local msg
    local withname=0
    local opt OPTIND

    while getopts :p opt;
    do
        case $opt in
            p) withname=1 ;;
        esac
    done
    shift $((OPTIND - 1)) # Shift away the processed options

    # Output messages
    for msg in "$@" ;
    do
        if [[ $withname -ne 0 ]];
        then
            msg="$PROGNAME: $msg"
        fi
        echo -e "$msg" 1>&2
    done
}

# Safely escapes a string for use as the replacement text in a sed command.
sedi_escape() {
    # Escapes characters for safe use in sed 's|...|HERE|g'
    echo -n "$1" |
    sed -e 's/\\/\\\\/g' -e 's/|/\\|/g' -e 's/&/\\&/g'
}


# Prompts user for app name and version for a local file and caches the result.
_prompt_for_local_details() {
    local uri="$1"
    # If already cached, do nothing.
    if [[ -v "APP_CACHE[$uri]" ]]; then
        return 0
    fi

    # Redirect this informational message to stderr to prevent command substitution capture.
    echo "Local image file detected: $uri" >&2

    local app version
    read -r -p "-> Enter the application name: " app
    if [[ -z "$app" ]];
    then
        warn -p "Error: Application name cannot be empty."
        return 1
    fi

    read -r -p "-> Enter the application version: " version
    if [[ -z "$version" ]];
    then
        warn -p "Error: Version cannot be empty."
        return 1
    fi

    APP_CACHE["$uri"]="$app"
    VER_CACHE["$uri"]="$version"
    return 0
}

# Populates the APP_CACHE and VER_CACHE for a given URI.
_ensure_uri_details_cached() {
    local uri="$1"
    # If already cached, do nothing.
    if [[ -v "APP_CACHE[$uri]" ]]; then
        return 0
    fi

    local app ver

    # If it's a local file, prompt the user for details.
    if [[ -f "$uri" ]]; then
        _prompt_for_local_details "$uri" || return 1
        return 0 # The cache is now populated.
    fi

    # --- If it's a remote URI, parse it and populate the cache ---

    # App parsing logic
	if [[ "$uri" == */qiime2/core:* ]];
	then
		app="qiime2"
	elif [[ "$uri" == */r-base:* ]]; then
		app="r"
	elif [[ "$uri" == */cumulusprod_cellranger:* ]]; then
		app="cellranger"
	elif [[ "$uri" == */nvidia/clara/clara-parabricks:* ]];
	then
		app="parabricks"
    elif [[ "$uri" == */nvidia/devtools/nsight-systems-cli:* ]];
    then
        app="nsightsys"
	else
		app="${uri##*/}"
		app=${app%%:*}
	fi

    # Version parsing logic
	ver="${uri##*/}"
	ver=${ver##*:}
	ver=$(echo "$ver" | sed -re 's/(--.*)?(_[0-9]+)?$//')

    # Populate the cache for the remote URI
    APP_CACHE["$uri"]="$app"
    VER_CACHE["$uri"]="$ver"
    return 0
}


# Function to display the help message
help_message() {
    scriptname="container-mod"
    cat <<-EOF

${scriptname} v$VERSION - Container Module Generator

This script streamlines the process of pulling container images and
automates the generation of module files and wrapper scripts.

Usage:
    ${scriptname} <subcommand> [options] <URIs>

Subcommands:
    pull        Pull the container image from the specified URIs.
    module      Generate module files for the specified URIs.
    exec        Generate wrapper scripts for the programs provided by the container.
    pipe        Pull, generate module files, and generate wrapper scripts for the specified URIs.

Options:
  -d, --dir DIR           Specify the output directory (default is the current directory).
  -f, --force             Force overwrite of existing files.
  -m, --moduledir DIR     Specify the directory for storing generated module files.
  -u, --update            Update the app file in the repos directory with the new version.
  -p, --personal          Create personal module files in the privatemodules directory.
  --profile               Use the specified profile for configuration.
  -j, --jupyter           Generate Jupyter kernels for the specified URIs.
  -h, --help              Display this help message and exit.

Examples:
    ${scriptname} pull docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} pipe -p docker://quay.io/biocontainers/vcftools:0.1.16

EOF
}

list_profiles() {
    # List available profiles
    if [ -d "${PROFILEHOMEDIR}" ];
    then
        for PROFILE in "${PROFILEHOMEDIR}"/*;
        do
            PROFILENAME="$(basename "${PROFILE}")"
            if [ "${PROFILENAME}" != "*" ];
            then
                echo "${PROFILENAME}  (Personal Profile)"
            fi
        done
    fi
    if [ -d "${PROFILEROOT}" ];
    then
        for PROFILE in "${PROFILEROOT}"/*;
        do
            PROFILENAME="$(basename "${PROFILE}")"
            if [ "${PROFILENAME}" != "*" ];
            then
                if [ -e "${PROFILEHOMEDIR}/${PROFILENAME}" ];
                then
                    echo "${PROFILENAME}  (Overridden)"
                else
                    echo "${PROFILENAME}"
                fi
            fi
        done
    fi
    exit 0
}

boxify_text()
{
	local msg=("$@")
	local line longest width
	for line in "${msg[@]}"; do
		if [[ ${#line} -gt $width ]]; then
			longest="$line"
			width="${#line}"
		fi
	done
	echo "+-${longest//?/-}-+"
	for line in "${msg[@]}";
	do
		printf '| %s%*s%s |\n' "$(tput bold)" "-$width" "$line" "$(tput sgr0)"
	done
	echo "+-${longest//?/-}-+"
}

# Create directory if it doesn't exist and set correct permissions
create_dir() {
    local dir_path="$1"
    local message="$2"
    if [[ ! -d "$dir_path" ]]; then
        mkdir -p -m 755 "$dir_path"
        echo "$message: $dir_path"
    fi
}

# Process a list of URIs with a given command
handle_subcommand() {
    local cmd="$1"
    shift

    for URI in "$@";
    do
        echo "Processing URI: $URI with the subcommand: $cmd"
        if ! "$cmd" "$URI"; then
            warn -p "Error executing command '$cmd' for URI: $URI"
            exit 1 # Halt on the first failure
        fi
    done
    return 0 # All commands succeeded
}

# Copy the AppInfo directory if missing
ensure_appinfo_dir() {
    if [[ "$personal" -eq 1 && ! -d "$HOME/container-apps/repos" ]]; then
        mkdir -p "$HOME/container-apps" ||
        {
            warn -p "Error: Failed to create directory $HOME/container-apps"
            return 1
        }
        if [[ -d "$AppInfo_DIR" ]];
        then
            cp -r "$AppInfo_DIR" "$HOME/container-apps/" ||
            {
                warn -p "Error: Failed to copy $AppInfo_DIR to $HOME/container-apps/"
                return 1
            }
        else
            warn -p "Error: Source directory $AppInfo_DIR does not exist"
            return 1
        fi
    fi
}

# Ensure app info file exists
ensure_appinfo_file() {
    local URI="$1"
    if [[ -z "$URI" ]];
    then
        warn -p "Error: URI parameter is missing."
        return 1
    fi

    local app
    app=$(uri2app "$URI") ||
    {
        warn -p "Error: Failed to extract app name from URI: $URI"
        return 1
    }

    local target_path
    if [[ ! -f "$HOME/container-apps/repos/$app" && ! -f "$AppInfo_DIR/$app" ]]; then
    	if [[ "$personal" -eq 1 ]];
    	then
        	target_path="$HOME/container-apps/repos/$app"
    	else
        	target_path="$AppInfo_DIR/$app"
    	fi
    	create_appinfo_file "$app" "$target_path" ||
    	{
        	warn -p "Error: Failed to create appinfo file for $app at $target_path"
        	return 1
    	}
    else
    	echo "Appinfo file already exists for $app, skipping creation."
    fi
}

###############################################################################
# URI to Name/Version/Module Converters
###############################################################################

uri2imgname() {
	local uri="$1"
    if [[ -f "$uri" ]];
    then
        basename "$uri"
        return 0
    fi
	local file=""
	file="${uri#*://}"
	file="${file//\//_}.sif"
	echo "$file"
}

uri2modname() {
	local uri="$1" file
	local app
    app=$(uri2app "$uri") || return 1
	local modver
    modver=$(uri2ver "$uri") || return 1

	file="$app/$modver.lua"
	echo "$file"
}

uri2app() {
    echo "${APP_CACHE[$1]}"
}

uri2ver() {
    echo "${VER_CACHE[$1]}"
}

###############################################################################
# Pull Singularity Images
###############################################################################
pull() {
    local uri=$1
    local is_local_file=0

    if [[ -f "$uri" ]];
    then
        is_local_file=1
    elif [[ "$uri" != *"://"* ]];
    then
        warn -p "Error: The specified local file does not exist: $uri"
        return 1
    fi

    if [[ $is_local_file -eq 1 ]];
    then
        echo "Local image file detected. Leaving it in its original location: $uri"
        # The user owns this file, so we do not change its permissions.
        return 0
    fi

    # --- For remote URIs, pull the image ---
    local imgname; imgname=$(uri2imgname "$uri") || return 1
    local image_outdir
    if [[ $personal -eq 1 ]]; then
        image_outdir="$PRIVATE_IMAGEDIR"
    else
        image_outdir="$PUBLIC_IMAGEDIR"
    fi

    local target_image_path="${image_outdir}/${imgname}"

    if [[ -e "$target_image_path" && $force -eq 0 ]];
    then
        echo "A file or link already exists: ${target_image_path}. Skipping."
        return
    fi

    mkdir -p "${image_outdir}"
    echo "Pulling Singularity image from '$uri' into $target_image_path..."
    singularity pull --force "$target_image_path" "$uri" || exit 1
    chmod 644 "$target_image_path"

}

###############################################################################
# Generate Modulefiles
###############################################################################
module() {
    local URI="$1"
    local module_outdir
    if [[ $personal -eq 1 ]];
    then
        module_outdir="$PRIVATE_MODULEDIR"
    else
        module_outdir="$MOD_OUTDIR"
    fi

    local modname
    modname=$(uri2modname "$URI") || return 1
    local OUTFILE="${module_outdir}/${modname}"

    if [[ -f "$OUTFILE" && $force -eq 0 ]];
    then
        echo "SKIPPED: $URI --> $OUTFILE (file exists)"
        return 0
    fi

    mkdir -p "$(dirname "$OUTFILE")" ||
    {
        warn -p "Error: Failed to create directory for '$OUTFILE'"
        exit 1
    }

    local MODULE
    MODULE=$(print_modulefile "$URI")

    if echo "$MODULE" > "$OUTFILE";
    then
        chmod 644 "$OUTFILE"
        echo "Generated module: $OUTFILE"
        echo "Remember to edit '$OUTFILE' stub (look for TODO: labels!)"
        echo
    else
        warn -p "Error: Failed to write to '$OUTFILE'"
        exit 1
    fi
}

print_modulefile() {
    local uri="$1"
    local app
    app=$(uri2app "$uri") || return 1
    local latest_modulefile
    latest_modulefile=$(find_latest_modulefile "$app")

    if [[ -z "$latest_modulefile" ]];
    then
        generate_new_modulefile "$uri"
    else
        repurpose_old_modulefile "$uri" "$latest_modulefile"
    fi
    return $?
}

find_latest_modulefile() {
    local app="$1"
    local latest_file=""
    local latest_time=0
    local MOD_EXISTING_DIRS

    if [[ $personal -eq 1 ]];
    then
        MOD_EXISTING_DIRS=("$HOME/privatemodules" "$MOD_EXISTING_DIR")
    else
        MOD_EXISTING_DIRS=("$MOD_EXISTING_DIR")
    fi

    for dir in "${MOD_EXISTING_DIRS[@]}";
    do
        if [[ -z "$dir" || ! -d "$dir/$app" ]]; then
            continue
        fi
        for f in "$dir/$app/"*.lua;
        do
            [[ -e "$f" ]] || continue
            current_time=$(stat -c %Y "$f")
            if (( current_time > latest_time )); then
                latest_time=$current_time
                latest_file="$f"
            fi
        done
    done
    echo "$latest_file"
}

generate_new_modulefile() {
    local uri="$1"
    local exec_outdir
    if [[ $personal -eq 1 ]];
    then
        exec_outdir="${PRIVATE_EXECUTABLE_DIR/#\$HOME/$HOME}"
    else
        exec_outdir="$PUBLIC_EXECUTABLE_DIR"
    fi

    local image; image=$(uri2imgname "$uri") || return 1
    local app; app=$(uri2app "$uri") || return 1
    local ver; ver=$(uri2ver "$uri") || return 1
    local homepage=""
    local description=""
    parse_home_description

    local registry=""
    local registry_url=""
    case "$uri" in
         *"biocontainers"*) registry="BioContainers"; registry_url="https://biocontainers.pro/tools/$app" ;;
        *"quay.io"*) registry="Quay.io"; registry_url="https://quay.io/repository/$app" ;;
        *"nvcr.io"*) registry="Nvidia NGC"; registry_url="https://catalog.ngc.nvidia.com/containers" ;;
        *"gcr.io"*) registry="Google Container Registry"; registry_url="$uri" ;;
        *) registry="DockerHub"; docker_repo=$(echo "$uri" | sed 's|docker://\([^:]*\):.*|\1|'); registry_url="https://hub.docker.com/r/${docker_repo}" ;;
    esac

    local template_file="${TEMPLATE_DIR}/module_template.lua"
    if [[ ! -f "$template_file" ]]; then
        warn -p "Error: Template file '$template_file' not found."
        return 1
    fi

    local esc_desc; esc_desc=$(sedi_escape "$description")
    local esc_reg; esc_reg=$(sedi_escape "$registry")
    local esc_reg_url; esc_reg_url=$(sedi_escape "$registry_url")
    local esc_homepage; esc_homepage=$(sedi_escape "$homepage")
    local esc_image; esc_image=$(sedi_escape "$image")
    local esc_uri; esc_uri=$(sedi_escape "$uri")
    local esc_ver; esc_ver=$(sedi_escape "$ver")
    local esc_exec_dir; esc_exec_dir=$(sedi_escape "$exec_outdir")
    local esc_app; esc_app=$(sedi_escape "$app")

    local modulefile_content
    modulefile_content=$(sed -e "s|\${DESCRIPTION}|$esc_desc|g" \
                             -e "s|\${REGISTRY}|$esc_reg|g" \
                             -e "s|\${REGISTRY_URL}|$esc_reg_url|g" \
                             -e "s|\${HOMEPAGE}|$esc_homepage|g" \
                             -e "s|\${IMAGE}|$esc_image|g" \
                             -e "s|\${URI}|$esc_uri|g" \
                             -e "s|\${VERSION}|$esc_ver|g" \
                             -e "s|\${EXECUTABLE_DIR}|$esc_exec_dir|g" \
                             -e "s|\${APP}|$esc_app|g" \
                             "$template_file")

    echo "$modulefile_content"
}

repurpose_old_modulefile() {
    local uri="$1"
    local template="$2"
    local image; image=$(uri2imgname "$uri") || return 1
    local ver; ver=$(uri2ver "$uri") || return 1

    local buf=$(awk -v ver="$ver" -v image="$image" -v uri="$uri" '
        /^[[:blank:]]*whatis.*Version:/ { $0 = "whatis(\"Version: " ver "\")" }
        /^[[:blank:]]*local[[:blank:]]+version[[:blank:]]*=/ { $0 = "local version = \"" ver "\"" }
        /^[[:blank:]]*local[[:blank:]]+image[[:blank:]]*=/ { $0 = "local image = \"" image "\"" }
        /^[[:blank:]]*local[[:blank:]]+uri[[:blank:]]*=/ { $0 = "local uri = \"" uri "\"" }
        /^[[:blank:]]*local[[:blank:]]+modroot[[:blank:]]*=/ {
            sub(/\.\. ".*"/, ".. \"" ver "\"")
        }
        { print }
    ' < "$template")

    if [[ $? -ne 0 || -z "$buf" ]]; then
        warn -p "Error: Failed to repurpose template '$template' for '$uri'"
        generate_new_modulefile "$uri"
        return $?
    fi
    echo "$buf"
}

###############################################################################
# Generate Executables
###############################################################################
exec() {
    local uri="$1"
    local app; app=$(uri2app "$uri") || return 1
    local ver; ver=$(uri2ver "$uri") || return 1

    local image_dir_for_wrapper image_name_for_wrapper
    if [[ -f "$uri" ]];
    then
        local absolute_path; absolute_path="$(realpath "$uri")"
        image_dir_for_wrapper="$(dirname "$absolute_path")"
        image_name_for_wrapper="$(basename "$absolute_path")"
    else
        if [[ $personal -eq 1 ]];
        then
            image_dir_for_wrapper="$PRIVATE_IMAGEDIR"
        else
            image_dir_for_wrapper="$PUBLIC_IMAGEDIR"
        fi
        image_name_for_wrapper=$(uri2imgname "$uri") || return 1
    fi

    local exec_array
    exec_array=($(parse_exec))
    if [ $? -ne 0 ]; then
        warn -p "No executables are defined for $app. Skipping exec generation."
        return 0
    fi

    local exec_outdir
    if [[ $personal -eq 1 ]]; then
        exec_outdir="$PRIVATE_EXECUTABLE_DIR"
    else
        exec_outdir="$EXEC_OUTDIR"
    fi

    local AppTool_dir="${exec_outdir}/${app}/${ver}/bin"
    if [[ -d "$AppTool_dir" && $force -eq 0 ]]; then
        warn -p "Output directory $AppTool_dir already exists. Skipping."
        return 0
    fi

    if [[ -d "$AppTool_dir" && $force -eq 1 ]]; then
        echo "Force option enabled, removing existing directory $AppTool_dir"
        rm -rf "$AppTool_dir" || { warn -p "Failed to remove dir $AppTool_dir"; exit 1; }
    fi
    mkdir -p "$AppTool_dir" || { warn -p "Failed to create dir $AppTool_dir"; exit 1; }

    echo "Generating executables for $app version $ver..."
    for command_exec in "${exec_array[@]}";
    do
        if confirm_exec_exists "$command_exec" "${image_dir_for_wrapper}/${image_name_for_wrapper}";
        then
            if generate_executable "$app" "$ver" "$command_exec" "$image_dir_for_wrapper" "$image_name_for_wrapper" "$AppTool_dir";
            then
                echo "  -> Successfully generated: $command_exec"
            else
                warn -p "  -> Error: Failed to generate executable: $command_exec"
            fi
        else
            warn -p "  -> Warning: Executable not found in container: $command_exec"
        fi
    done
}

confirm_exec_exists() {
    local exec=$1
    local image=$2
    if ! singularity exec "$image" which "$exec" &> /dev/null; then
        return 1
    else
        return 0
    fi
}

generate_executable() {
    local app=$1 version=$2 command=$3 image_dir=$4 image_name=$5 AppTool_dir=$6
    local executable="${AppTool_dir}/${command}"

    if [[ -z "$app" || -z "$version" || -z "$command" || -z "$image_dir" || -z "$image_name" || -z "$AppTool_dir" ]];
    then
        warn -p "Error: Missing arguments for generate_executable"
        return 1
    fi

    mkdir -p "$(dirname "$executable")"

    cat <<EOF >"$executable"
#!/usr/bin/env bash
# Wrapper script for $command from container $image_name

# Set variables
VER="$version"
PKG="$app"
PROGRAM="$command"
IMAGE_DIR="$image_dir"
IMAGE="$image_name"

# Load Singularity if it is not already loaded
if ! command -v singularity &> /dev/null; then
    module load singularity || { echo "Failed to load Singularity module"; exit 1; }
fi

# Determine GPU flags for Singularity
OPTIONS=""
if nvidia-smi -L &> /dev/null; then
    OPTIONS="--nv"
fi
if rocm-smi -L &> /dev/null; then
    OPTIONS="\$OPTIONS --rocm"
fi

# Run the container with appropriate options
singularity exec \$OPTIONS "\$IMAGE_DIR/\$IMAGE" "\$PROGRAM" "\$@"
EOF

    chmod 755 "$executable"
    if [[ $? -ne 0 ]]; then
        warn -p "Error: Failed to set permissions for wrapper $command"
        return 1
    fi
}

###############################################################################
# App Info and Executable Parsing
###############################################################################

create_appinfo_file() {
    local app=$1
    local localappinfo=$2
    echo "$app is not found in our application information database."
    echo "let's create a new entry for $app."
    read -p "Enter a simple description of your application: " description
    read -p "Enter the homepage of your application: " homepage
    read -p "Enter the programs available (comma-separated): " programs
    mkdir -p "$(dirname "$localappinfo")"
    echo "Description: $description" > "$localappinfo"
    echo "Home Page: $homepage" >> "$localappinfo"
    echo "Programs: $programs" >> "$localappinfo"
}

parse_home_description() {
    local app_file
    APP_INFO_PATH=("$HOME/container-apps/repos" "$AppInfo_DIR")
    for path in "${APP_INFO_PATH[@]}";
    do
        if [[ -f "$path/$app" ]];
        then
            app_file="$path/$app"
            break
        fi
    done

    if [[ -f "$app_file" ]]; then
        description=$(grep -m1 "^Description:" "$app_file" | sed 's/^Description: //')
        homepage=$(grep -m1 "^Home Page:" "$app_file" | sed 's/^Home Page: //')
    fi
}

parse_exec() {
    local app_file
    APP_INFO_PATH=("$HOME/container-apps/repos" "$AppInfo_DIR")
    for path in "${APP_INFO_PATH[@]}";
    do
        if [[ -f "$path/$app" ]];
        then
            app_file="$path/$app"
            break
        fi
    done

    if [[ ! -f "$app_file" ]]; then
        warn -p "Error: Application file '$app_file' not found."
        return 1
    fi

    local executables
    executables=$(grep -m1 "^Programs:" "$app_file" | sed 's/^Programs: //')

    if [[ -z "$executables" ]];
    then
        return 1
    fi

    IFS=',' read -r -a arr <<< "$executables"
    echo "${arr[@]}"
}

###############################################################################
# Jupyter Kernel Creation
###############################################################################
jupyter() {
    local uri=$1
    local app; app=$(uri2app "$uri") || return 1
    local ver; ver=$(uri2ver "$uri") || return 1
    local image; image=$(uri2imgname "$uri") || return 1
    local kernel_name="${app}-${ver}"
    local kernel_dir
    if [[ $personal -eq 1 ]]; then
        kernel_dir="$HOME/.local/share/jupyter/kernels/$kernel_name"
    else
        kernel_dir="${JUPYTER_OUTDIR}/${kernel_name}"
    fi

    local image_outdir
    if [[ $personal -eq 1 ]]; then
        image_outdir="$PRIVATE_IMAGEDIR"
    else
        image_outdir="$PUBLIC_IMAGEDIR"
    fi

    if ! singularity exec "${image_outdir}/${image}" python -c "import ipykernel" &> /dev/null; then
        MSG=( "The dependency ipykernel is not detected in ${image}." "" "Please add it to your container:" "" "   pip install ipython ipykernel" )
        boxify_text "${MSG[@]}"
        exit 1
    fi

    if [[ ! -d "$kernel_dir" ]]; then
        mkdir -p "$kernel_dir"
        cp "$SCRIPT_TOP_DIR/jupyter_kernel.json" "${kernel_dir}/kernel.json"

        local exec_outdir
        if [[ $personal -eq 1 ]]; then
            exec_outdir="${PRIVATE_EXECUTABLE_DIR/#\$HOME/$HOME}"
        else
            exec_outdir="$PUBLIC_EXECUTABLE_DIR"
        fi

        local AppTool_dir="${exec_outdir}/${app}/${ver}/bin"
        local esc_apptool_dir; esc_apptool_dir=$(sedi_escape "$AppTool_dir")
        local esc_app; esc_app=$(sedi_escape "$app")
        local esc_ver; esc_ver=$(sedi_escape "$ver")

        sed -i -e "s|APPDIR|$esc_apptool_dir|g" \
               -e "s|APP|$esc_app|g" \
               -e "s|VERSION|$esc_ver|g" \
               "${kernel_dir}/kernel.json"
    else
        echo "Kernel already exists: $kernel_dir"
    fi
    echo "Jupyter kernel created: $kernel_name"
    MSG=( "You can now launch Jupyter and select the kernel:" "" "   $app $ver" )
    boxify_text "${MSG[@]}"
}

###############################################################################
# Main Script Starts Here
###############################################################################

# --- Default configuration options ---
force=0
personal=0
jupyter=0
SCRIPT_TOP_DIR="$(realpath "${BASH_SOURCE[0]}" | xargs dirname)"
TEMPLATE_DIR="$SCRIPT_TOP_DIR/templates"
AppInfo_DIR="${SCRIPT_TOP_DIR}/repos"
PROFILEROOT="${SCRIPT_TOP_DIR}/profiles"
OUTDIR_DEF="."
OUTDIR="${OUTDIR:-$OUTDIR_DEF}"
MOD_OUTDIR="${OUTDIR}/incomplete"
EXEC_OUTDIR="${OUTDIR}/executables"
JUPYTER_OUTDIR="${OUTDIR}/kernels"
PRIVATE_EXECUTABLE_DIR="$HOME/container-apps/tools"
PRIVATE_MODULEDIR="$HOME/privatemodules"
PRIVATE_IMAGEDIR="$HOME/container-apps/images"
PROFILEHOMEDIR="$HOME/container-apps/profiles"

# --- Subcommand validation ---
SUBCOMMAND="$1"
if [[ -z "$SUBCOMMAND" || "$SUBCOMMAND" == "-h" || "$SUBCOMMAND" == "--help" ]]; then
    help_message
    exit 0
fi
if [[ "$SUBCOMMAND" == "-l" || "$SUBCOMMAND" == "--list" ]]; then
    list_profiles
    exit 0
fi
shift

# --- Command-Line Option Parsing ---
declare -a ARGV
while [[ -n "$1" ]];
do
    case $1 in
        --profile) shift; PROFILE="$1" ;;
        -d|--dir|--directory) shift; OUTDIR="$1" ;;
        -f|--force) force=1 ;;
        -m|--module-dir|--module-directory) shift; MOD_EXISTING_DIR="$1" ;;
        -u|--update) update_repo=1 ;;
        -p|--personal) personal=1 ;;
        -j|--jupyter) jupyter=1 ;;
        --) shift; break ;;
        -*) warn -p "Unknown option: $1"; help_message; exit 1 ;;
        *) ARGV+=("$1") ;;
    esac
    shift
done
set -- "${ARGV[@]}"

# --- Profile Loading ---
if [[ -n "$PROFILE" ]];
then
    if [[ -f "${PROFILEHOMEDIR}/$PROFILE" ]];
    then
        echo "Loading profile from personal directory: $PROFILE"
        source "${PROFILEHOMEDIR}/$PROFILE"
    elif [[ -f "${PROFILEROOT}/$PROFILE" ]];
    then
        echo "Loading profile from root directory: $PROFILE"
        source "${PROFILEROOT}/$PROFILE"
    else
        warn -p "Error: Profile '$PROFILE' not found."
        exit 1
    fi
else
    echo "No profile specified. Running in personal mode!"
    personal=1
fi

MOD_EXISTING_DIR="${MOD_EXISTING_DIR:-$MOD_EXISTING_DIR_DEF}"

# --- Initialization ---
ensure_appinfo_dir

for URI in "$@";
do
    _ensure_uri_details_cached "$URI" || { warn -p "Could not get app details for $URI"; exit 1; }
    ensure_appinfo_file "$URI"
done

if [[ $personal -eq 1 ]];
then
    create_dir "$PRIVATE_EXECUTABLE_DIR" "Created personal executable directory"
    create_dir "$PRIVATE_MODULEDIR" "Created personal module directory"
    create_dir "$PRIVATE_IMAGEDIR" "Created personal image directory"
else
    create_dir "$EXEC_OUTDIR" "Created public executable directory"
    create_dir "$MOD_OUTDIR" "Created public module directory"
    if [[ -n "$PUBLIC_IMAGEDIR" ]]; then create_dir "$PUBLIC_IMAGEDIR" "Created public image directory"; fi
fi

# --- Subcommand Handling ---
case "$SUBCOMMAND" in
    pull)
        handle_subcommand pull "$@" ;;
    module)
        handle_subcommand module "$@" ;;
    exec)
        handle_subcommand exec "$@" ;;
    pipe)
        handle_subcommand pull "$@"
        handle_subcommand module "$@"
        handle_subcommand exec "$@" ;;
    *)
        warn -p "Invalid subcommand: $SUBCOMMAND"
        help_message >&2
        exit 1 ;;
esac

# --- Final Messages ---
if [[ "$SUBCOMMAND" == "module" || "$SUBCOMMAND" == "pipe" ]]; then
    for URI in "$@"; do
        app=$(uri2app "$URI") || continue
        ver=$(uri2ver "$URI") || continue
        modname=$(uri2modname "$URI") || continue
        if [[ $personal -eq 1 ]]; then
            MSG=( "To use this module, load:" "" "    module load use.own" "    module load $app/$ver" )
        else
            MSG=( "To use this module, load:" "" "    module use $MOD_OUTDIR" "    module load $app/$ver" )
        fi
        boxify_text "${MSG[@]}"
    done
fi

if [[ $jupyter -eq 1 ]]; then
    for URI in "$@"; do
        echo "Generating Jupyter kernel for $URI"
        if ! jupyter "$URI"; then
            warn -p "Error creating Jupyter kernel for $URI"
        fi
    done
fi