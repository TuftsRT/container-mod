#!/bin/bash

# Yucheng Zhang

# Copyright (c) 2024 Tufts University
# This script is modified from the original script written by Lev Gorenstein from Purdue University.
# The original script is available at (https://github.com/PurdueRCAC/Biocontainers).

# This script assumes that you have Singularity or Apptainer
# installed on your system.
#
# Usage: Run "container-mod --help" for instructions.
VERSION="0.1.3" # Increment this version for updates

###############################################################################
# Prerequisites: Ensure Singularity or Apptainer is available
###############################################################################

if ! command -v singularity > /dev/null 2>&1; then
    if module load singularity 2>/dev/null; then
        :
    else
        if module load apptainer 2>/dev/null; then
            :
        else
            echo "Failed to load both Singularity and Apptainer modules."
            exit 1
        fi
    fi
fi

###############################################################################
# Helper functions
###############################################################################

# --- Caches for app name and version to avoid repeated prompting ---
declare -A APP_CACHE
declare -A VER_CACHE

clean_up() {
	# Perform pre-exit housekeeping
	return
}

# Function to print a message and exit with a status
graceful_exit() {
	# graceful_exit [status]]
	clean_up
	exit ${1:-$E_OK}
}

# Function to send warning messages to stderr.
warn() {
    # warn [-p] "message" ["message"...]
    # Sends message(s) to stderr, optionally prefixing with "PROGNAME: ".
    local msg
    local withname=0
    local opt OPTIND

    while getopts :p opt; do
        case $opt in
            p) withname=1 ;;
        esac
    done
    shift $((OPTIND - 1)) # Shift away the processed options

    # Output messages
    for msg in "$@" ; do
        if [[ $withname -ne 0 ]]; then
            msg="$PROGNAME: $msg"
        fi
        echo -e "$msg" 1>&2
    done
}

# Safely escapes a string for use as the replacement text in a sed command.
# This function handles characters that have a special meaning in the replacement
# part of a sed 's' command, such as backslashes (\) and ampersands (&).
# It also escapes the pipe character (|), which is used as the delimiter
# in this script's sed commands, preventing syntax errors.
#
# @param $1 The input string to escape.
# @return Prints the escaped string to standard output.
sedi_escape() {
    # Escapes characters for safe use in sed 's|...|HERE|g'
    echo -n "$1" | sed -e 's/\\/\\\\/g' -e 's/|/\\|/g' -e 's/&/\\&/g'
}


# Prompts user for app name and version for a local file and caches the result.
# This internal function is called by _ensure_uri_details_cached.
_prompt_for_local_details() {
    local uri="$1"
    # If already cached, do nothing.
    if [[ -v "APP_CACHE[$uri]" ]]; then
        return 0
    fi

    # Redirect this informational message to stderr to prevent command substitution capture.
    echo "Local image file detected: $uri" >&2

    local app version
    read -r -p "-> Enter the application name: " app
    if [[ -z "$app" ]]; then
        echo "Error: Application name cannot be empty." >&2
        return 1
    fi

    read -r -p "-> Enter the application version: " version
    if [[ -z "$version" ]]; then
        echo "Error: Version cannot be empty." >&2
        return 1
    fi

    APP_CACHE["$uri"]="$app"
    VER_CACHE["$uri"]="$version"
    return 0
}

# Populates the APP_CACHE and VER_CACHE for a given URI.
# This function is called directly to ensure it can modify the global cache arrays
# without being affected by subshells from command substitution.
_ensure_uri_details_cached() {
    local uri="$1"
    # If already cached, do nothing.
    if [[ -v "APP_CACHE[$uri]" ]]; then
        return 0
    fi

    local app ver

    # If it's a local file, prompt the user for details.
    if [[ -f "$uri" ]]; then
        # This call to the prompter is now safe because this parent
        # function is not called with command substitution.
        _prompt_for_local_details "$uri" || return 1
        return 0 # The cache is now populated.
    fi

    # --- If it's a remote URI, parse it and populate the cache ---

    # App parsing logic (from the old uri2app)
	if [[ "$uri" == */qiime2/core:* ]]; then
		app="qiime2"
	elif [[ "$uri" == */r-base:* ]]; then
		app="r"
	elif [[ "$uri" == */cumulusprod_cellranger:* ]]; then
		app="cellranger"
	elif [[ "$uri" == */nvidia/clara/clara-parabricks:* ]]; then
		app="parabricks"
    elif [[ "$uri" == */nvidia/devtools/nsight-systems-cli:* ]]; then
        app="nsightsys"
	else
		app="${uri##*/}"
		app=${app%%:*}
	fi

    # Version parsing logic (from the old uri2ver)
	ver="${uri##*/}"
	ver=${ver##*:}
	ver=$(echo "$ver" | sed -re 's/(--.*)?(_[0-9]+)?$//')

    # Populate the cache for the remote URI
    APP_CACHE["$uri"]="$app"
    VER_CACHE["$uri"]="$ver"
    return 0
}


# Function to display the help message
help_message() {
    scriptname="container-mod"
    cat <<-EOF

${scriptname} v$VERSION - Container Module Generator

This script streamlines the process of pulling container images from public registries,
and automates the generation of module files and wrapper scripts,
enabling users to seamlessly run containers as if they were standard software modules.
Usage:
    ${scriptname} <subcommand> [options] <URIs>

Subcommands:
    pull        Pull the container image from the specified URIs.
    module      Generate module files for the specified URIs.
    exec        Generate wrapper scripts for the programs provided by the container.
    pipe        Pull, generate module files, and generate wrapper scripts for the specified URIs.
Options:
  -d, --dir DIR           Specify the output directory for images and module files (default is the current directory).
  -f, --force             Force overwrite of existing images and module files (default behavior is to skip).
  -m, --moduledir DIR     Specify the directory for storing generated module files.
  -u, --update            Update the app file in the repos directory with the new version (default is no).
  -p, --personal          Create personal module files in the privatemodules directory (default is no).
  --profile               Use the specified profile for configuration.
Available profiles are stored in profiles directory.
  -j, --jupyter           Generate Jupyter kernels for the specified URIs.
  -h, --help              Display this help message and exit.
Examples:
    ${scriptname} pull docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} module docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} exec docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} pipe -p docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} pipe --profile biocontainer docker://quay.io/biocontainers/vcftools:0.1.16

EOF
}

list_profiles() {
    # List available profiles
    if [ -d "${PROFILEHOMEDIR}" ]; then
        for PROFILE in "${PROFILEHOMEDIR}"/*; do
            PROFILENAME="$(basename "${PROFILE}")"
            if [ "${PROFILENAME}" != "*" ]; then
                echo "${PROFILENAME}  (Personal Profile)"
            fi
        done
    fi
    if [ -d "${PROFILEROOT}" ]; then
        for PROFILE in "${PROFILEROOT}"/*; do
            PROFILENAME="$(basename "${PROFILE}")"
            if [ "${PROFILENAME}" != "*" ]; then
                if [ -e "${PROFILEHOMEDIR}/${PROFILENAME}" ]; then
                    echo "${PROFILENAME}  (Overridden)"
                else
                    echo "${PROFILENAME}"
                fi
            fi
        done
    fi
    exit 0
}

boxify_text()
{
	#
	# Usage: boxify_text AAAA [BBB ...]
	#
	# Output:
	#	+------+
	#	| AAAA |
	#	| BBB  |
	#	+------+
	#
	local msg=("$@")
	local line longest width
	for line in "${msg[@]}"; do
		if [[ ${#line} -gt $width ]]; then
			longest="$line"
			width="${#line}"
		fi
	done
	echo "+-${longest//?/-}-+"
	for line in "${msg[@]}"; do
		printf '| %s%*s%s |\n' "$(tput bold)" "-$width" "$line" "$(tput sgr0)"
	done
	echo "+-${longest//?/-}-+"
}

# Create directory if it doesn't exist
create_dir() {
    local dir_path="$1"
    local message="$2"
    if [[ ! -d "$dir_path" ]]; then
        mkdir -p "$dir_path"
        echo "$message: $dir_path"
    fi
}

# Process a list of URIs with a given command
handle_subcommand() {
    local cmd="$1"
    shift

    for URI in "$@"; do
        echo "Processing URI: $URI with the subcommand: $cmd"
        if ! "$cmd" "$URI"; then
            echo "Error executing command '$cmd' for URI: $URI" >&2
            exit 1 # Halt on the first failure
        fi
    done
    return 0 # All commands succeeded
}

# Copy the AppInfo directory if missing
ensure_appinfo_dir() {
    # Ensure the personal mode is enabled and the target directory doesn't exist
    if [[ "$personal" -eq 1 && ! -d "$HOME/container-apps/repos" ]]; then
        # Create the directory if it doesn't exist
        mkdir -p "$HOME/container-apps" || {
            echo "Error: Failed to create directory $HOME/container-apps" >&2
            return 1
        }

        # Copy the AppInfo directory
        if [[ -d "$AppInfo_DIR" ]]; then
            cp -r "$AppInfo_DIR" "$HOME/container-apps/" || {
                echo "Error: Failed to copy $AppInfo_DIR to $HOME/container-apps/" >&2
                return 1
            }
        else
            echo "Error: Source directory $AppInfo_DIR does not exist" >&2
            return 1
        fi
    fi
}

# Ensure app info file exists
ensure_appinfo_file() {
    local URI="$1"

    # Validate input argument
    if [[ -z "$URI" ]]; then
        echo "Error: URI parameter is missing." >&2
        return 1
    fi

    local app
    app=$(uri2app "$URI") || {
        echo "Error: Failed to extract app name from URI: $URI" >&2
        return 1
    }

    # Determine the target path for the appinfo file
    local target_path
    echo "Checking existence of files for $app"
    echo "$HOME/container-apps/repos/$app exists? $(test -f "$HOME/container-apps/repos/$app" && echo yes || echo no)"
    echo "$AppInfo_DIR/$app exists? $(test -f "$AppInfo_DIR/$app" && echo yes || echo no)"

    if [[ ! -f "$HOME/container-apps/repos/$app" && ! -f "$AppInfo_DIR/$app" ]]; then
    	if [[ "$personal" -eq 1 ]]; then
        	target_path="$HOME/container-apps/repos/$app"
    	else
        	target_path="$AppInfo_DIR/$app"
    	fi
    	echo "Debug: target_path is set to $target_path"
    	# Create the appinfo file
    	create_appinfo_file "$app" "$target_path" || {
        	echo "Error: Failed to create appinfo file for $app at $target_path" >&2
        	return 1
    	}
    else
    	echo "Appinfo file already exists for $app, skipping creation."
    fi
}

###############################################################################
# Functions for converting URIs to module names, app names, and versions
###############################################################################

uri2imgname() {
	# uri2imgname "URI"
	# Converts a URI to a Singularity image filename.
	# Handles both local file paths and remote URIs correctly.
	local uri="$1"

    # If the URI is an existing local file, use basename to return only the filename.
    # This correctly strips the entire path prefix.
    if [[ -f "$uri" ]]; then
        basename "$uri"
        return 0
    fi

    # Original logic for remote URIs
	local file=""
	file="${uri#*://}" 		# Drop {docker,https}:// prefix, if any
	file="${file//\//_}.sif" 	# And replace '/' with '_'
	echo "$file"
}

uri2modname() {
	# uri2modname "URI"
	local uri="$1" file
	local app
    app=$(uri2app "$uri") || return 1
	local modver
    modver=$(uri2ver "$uri") || return 1

	file="$app/$modver.lua"
	echo "$file"
}


uri2app() {
	# uri2app "URI"
	# Safely returns the cached application name for a given URI.
	# Assumes the cache has been populated by _ensure_uri_details_cached.
    echo "${APP_CACHE[$1]}"
}


uri2ver() {
	# uri2ver "URI"
	# Safely returns the cached version for a given URI.
	# Assumes the cache has been populated by _ensure_uri_details_cached.
    echo "${VER_CACHE[$1]}"
}

###############################################################################
# Functions for pulling Singularity images
###############################################################################
pull() {
    # pull "URI" or "PATH_TO_IMAGE"
    # Pulls a Singularity image from a remote URI. For local images, it does nothing.
    local uri=$1
    local is_local_file=0

    # Determine if the input is a local file path or a remote URI
    if [[ -f "$uri" ]]; then
        is_local_file=1
    elif [[ "$uri" != *"://"* ]]; then
        echo "Error: The specified local file does not exist: $uri" >&2
        return 1
    fi

    # --- For local files, do nothing and return (but handle repo update) ---
    if [[ $is_local_file -eq 1 ]]; then
        echo "Local image file detected. Leaving it in its original location: $uri"
        if [[ $update_repo -eq 1 ]]; then
            local app; app=$(uri2app "$uri") || return 1
            local version; version=$(uri2ver "$uri") || return 1
            local app_file="$AppInfo_DIR/$app"
            if [[ $personal -eq 1 ]]; then
                app_file="$HOME/container-apps/repos/$app"
            fi

            if [[ ! -f "$app_file" ]]; then
                echo "Error: App file '$app_file' not found for update. Please create it first." >&2
                return 1
            fi
            local repo_uri; repo_uri="$(realpath "$uri")"
            local temp_file="${app_file}.tmp"
            {
                grep -v '^version(' "$app_file"
                echo "version(\"$version\", uri=\"$repo_uri\")"
                grep '^version(' "$app_file"
            } > "$temp_file"
            if mv "$temp_file" "$app_file"; then
                echo "Updated app file: $app_file with new version $version"
            else
                echo "Error: Failed to update app file '$app_file'." >&2
                return 1
            fi
        fi
        return 0
    fi

    # --- For remote URIs, pull the image as before ---
    local app; app=$(uri2app "$uri") || return 1
    local version; version=$(uri2ver "$uri") || return 1
    local imgname; imgname=$(uri2imgname "$uri") || return 1

    local image_outdir
    if [[ $personal -eq 1 ]]; then
        image_outdir="$PRIVATE_IMAGEDIR"
    else
        image_outdir="$PUBLIC_IMAGEDIR"
    fi

    local target_image_path="${image_outdir}/${imgname}"

    if [[ -e "$target_image_path" ]]; then
        echo "A file or link already exists: ${target_image_path}"
        return
    fi

    mkdir -p "${image_outdir}"
    echo "Pulling Singularity image from '$uri'..."
    singularity pull "$target_image_path" "$uri" || exit 1

    # --- Update repository file if requested (for remote pulls) ---
    if [[ $update_repo -eq 1 ]]; then
        local app_file="$AppInfo_DIR/$app"
        if [[ $personal -eq 1 ]]; then
             app_file="$HOME/container-apps/repos/$app"
        fi
        if [[ ! -f "$app_file" ]]; then
            echo "Error: App file '$app_file' not found. Please create it first." >&2
            rm -f "$target_image_path"
            return 1
        fi

        local repo_uri="$uri"
        local temp_file="${app_file}.tmp"
        {
            grep -v '^version(' "$app_file"
            echo "version(\"$version\", uri=\"$repo_uri\")"
            grep '^version(' "$app_file"
        } > "$temp_file"

        if [[ ! -s "$temp_file" ]]; then
            echo "Error: Failed to create temporary update file '$temp_file'." >&2
            rm -f "$target_image_path"
            return 1
        fi

        if mv "$temp_file" "$app_file"; then
            echo "Updated app file: $app_file with new version $version"
        else
            echo "Error: Failed to update app file '$app_file'." >&2
            rm -f "$temp_file" "$target_image_path"
            return 1
        fi
    fi
}

###############################################################################
# Functions for generating modulefiles
###############################################################################
module() {
    # module "URI"
    local URI="$1"

    # Testing whether we are generating personal or public modules
    if [[ $personal -eq 1 ]]; then
        local module_outdir="$PRIVATE_MODULEDIR"
    else
        local module_outdir="$MOD_OUTDIR"
    fi

    local modname
    modname=$(uri2modname "$URI") || return 1
    local OUTFILE="${module_outdir}/${modname}"

    # If modulefile already exists, skip it (unless --force is in effect)
    if [[ -f "$OUTFILE" && $force -eq 0 ]]; then
        echo "SKIPPED: $URI --> $OUTFILE (file exists)"
        SKIPPED_URIS+=("$URI")
        return 0
    fi

    # If force is true and module file exists, remove it before creating a new one
    if [[ -f "$OUTFILE" && $force -eq 1 ]]; then
        echo "Force option enabled, removing existing module file $OUTFILE"
        rm -rf "$OUTFILE" || {
            echo "Error: Failed to remove existing module file $OUTFILE"
            exit 1
        }
    fi

    # Create the directory, exit on failure
    mkdir -p "$(dirname "$OUTFILE")" || {
        echo "Error: Failed to create directory for '$OUTFILE'"
        exit 1
    }

    # Generate module file content
    MODULE=$(print_modulefile "$URI")

    # Write module content to the file, exit on failure
    if echo "$MODULE" > "$OUTFILE"; then
        echo "Remember to edit '$OUTFILE' stub (look for TODO: labels!)"
        echo
    else
        echo "Error: Failed to write to '$OUTFILE'"
        exit 1
    fi
}

print_modulefile() {
    # print_modulefile "URI"
    local uri="$1"
    local app
    app=$(uri2app "$uri") || return 1             # e.g., vcftools
    local latest_modulefile
    latest_modulefile=$(find_latest_modulefile "$app") # file or empty

    # Check if no latest modulefile exists
    if [[ -z "$latest_modulefile" ]]; then
        # Generate a new modulefile
        generate_new_modulefile "$uri" || {
            echo "Error: Failed to generate new modulefile for $app"
            return 1
        }
    else
        # Repurpose the old modulefile
        repurpose_old_modulefile "$uri" "$latest_modulefile" || {
            echo "Error: Failed to repurpose modulefile for $app"
            return 1
        }
    fi

    # Return the status of the last executed command (generator)
    return $?
}


find_latest_modulefile() {
    # find_latest_modulefile "app"
    local app="$1"
    local modulefile=""

    # Testing whether we are generating personal or public apps
    # If personal, search in both privatemodules and the designated module directory
    if [[ $personal -eq 1 ]]; then
        local MOD_EXISTING_DIRS=("$HOME/privatemodules" "$MOD_EXISTING_DIR")
    else
        local MOD_EXISTING_DIRS=("$MOD_EXISTING_DIR")
    fi

    # Loop through all directories and find all *.lua files
    for dir in "${MOD_EXISTING_DIRS[@]}"; do
    # Check if there are any *.lua files in this directory
    if ls "$dir/$app/"*.lua 1> /dev/null 2>&1; then
        # Find the most recent modulefile in this directory
        latest_file=$(ls -t "$dir/$app/"*.lua | head -n 1)

        # If modulefile is empty or latest_file is more recent, update modulefile
        if [[ -z "$modulefile" || "$latest_file" -nt "$modulefile" ]]; then
            modulefile="$latest_file"
        fi
    fi
    done

    echo "$modulefile"
}


generate_new_modulefile() {
    # generate_new_modulefile "URI"
    local uri="$1"

    # Testing whether we are generating personal or public apps
    if [[ $personal -eq 1 ]]; then
        local exec_outdir="${PRIVATE_EXECUTABLE_DIR/#\$HOME/$HOME}"
    else
        local exec_outdir="$PUBLIC_EXECUTABLE_DIR"
    fi

    local image; image=$(uri2imgname "$uri") || return 1
    local app; app=$(uri2app "$uri") || return 1
    local ver; ver=$(uri2ver "$uri") || return 1


    # Initialize description and homepage variables
    local homepage=""
    local description=""
    parse_home_description

    # Determine the registry and registry URL
    local registry=""
    local registry_url=""

    case "$uri" in
         *"biocontainers"*)
            registry="BioContainers"
            registry_url="https://biocontainers.pro/tools/$app"
            ;;
         *"quay.io"*)
            registry="Quay.io"
            registry_url="https://quay.io/repository/$app"
            ;;
         *"nvcr.io"*)
            registry="Nvidia NGC"
            registry_url="https://catalog.ngc.nvidia.com/containers"
            ;;
         *"gcr.io"*)
            registry="Google Container Registry"
            registry_url="$uri"
            ;;
         *)
            registry="DockerHub"
            docker_repo=$(echo "$uri" | sed 's|docker://\([^:]*\):.*|\1|')
            registry_url="https://hub.docker.com/r/${docker_repo}"
            ;;
    esac

    # Ensure template file exists
    local template_file="${TEMPLATE_DIR}/module_template.lua"
    if [[ ! -f "$template_file" ]]; then
        echo "Error: Template file '$template_file' not found."
        return 1
    fi

    # Escape all variables before substituting them into the template
    local esc_desc; esc_desc=$(sedi_escape "$description")
    local esc_reg; esc_reg=$(sedi_escape "$registry")
    local esc_reg_url; esc_reg_url=$(sedi_escape "$registry_url")
    local esc_homepage; esc_homepage=$(sedi_escape "$homepage")
    local esc_image; esc_image=$(sedi_escape "$image")
    local esc_uri; esc_uri=$(sedi_escape "$uri")
    local esc_ver; esc_ver=$(sedi_escape "$ver")
    local esc_exec_dir; esc_exec_dir=$(sedi_escape "$exec_outdir")
    local esc_app; esc_app=$(sedi_escape "$app")


    # Substitute placeholders in the template using the escaped variables
    local modulefile_content
    modulefile_content=$(sed -e "s|\${DESCRIPTION}|$esc_desc|g" \
                             -e "s|\${REGISTRY}|$esc_reg|g" \
                             -e "s|\${REGISTRY_URL}|$esc_reg_url|g" \
                             -e "s|\${HOMEPAGE}|$esc_homepage|g" \
                             -e "s|\${IMAGE}|$esc_image|g" \
                             -e "s|\${URI}|$esc_uri|g" \
                             -e "s|\${VERSION}|$esc_ver|g" \
                             -e "s|\${EXECUTABLE_DIR}|$esc_exec_dir|g" \
                             -e "s|\${APP}|$esc_app|g" \
                             "$template_file")

    # Output the generated modulefile
    echo "$modulefile_content"
    return $MODTYPE_NEW
}


repurpose_old_modulefile() {
    # repurpose_old_modulefile "URI" "TEMPLATE"
    local uri="$1"
    local template="$2"
    local image
    image=$(uri2imgname "$uri") || return 1
    local app
    app=$(uri2app "$uri") || return 1
    local ver
    ver=$(uri2ver "$uri") || return 1

    # Modify the template with new version, image, and URI
    local buf=$(awk -v ver="$ver" -v image="$image" -v uri="$uri" '
        /^[[:blank:]]*whatis.*Version:/ { $0 = "whatis(\"Version: " ver "\")" }
        /^[[:blank:]]*local[[:blank:]]+version[[:blank:]]*=/ { $0 = "local version = \"" ver "\"" }
        /^[[:blank:]]*local[[:blank:]]+image[[:blank:]]*=/ { $0 = "local image = \"" image "\"" }
        /^[[:blank:]]*local[[:blank:]]+uri[[:blank:]]*=/ { $0 = "local uri = \"" uri "\"" }
        # Modify modroot to replace the version part after .. with the version (ver)
        /^[[:blank:]]*local[[:blank:]]+modroot[[:blank:]]*=/ {
        # Match the modroot assignment and replace the version after ..
        sub(/\.\. ".*"/, ".. \"" ver "\"")
        }
        { print }
    ' < "$template")

    # Check if the template modification succeeded
    if [[ $? -ne 0 || -z "$buf" ]]; then
        warn -p "Error: Failed to repurpose template '$template' for '$uri'"
        generate_new_modulefile "$uri"
        return $?
    fi

    echo "$buf"
    return $MODTYPE_EXISTING
}

###############################################################################
# Functions for generating executables
###############################################################################
exec() {
    # exec "URI"
    local uri="$1"
    local app; app=$(uri2app "$uri") || return 1
    local ver; ver=$(uri2ver "$uri") || return 1

    local image_dir_for_wrapper image_name_for_wrapper
    if [[ -f "$uri" ]]; then
        # For local files, split the absolute path into its directory and filename
        local absolute_path; absolute_path="$(realpath "$uri")"
        image_dir_for_wrapper="$(dirname "$absolute_path")"
        image_name_for_wrapper="$(basename "$absolute_path")"
    else
        # For remote files, use the managed image directory from the profile
        if [[ $personal -eq 1 ]]; then
            image_dir_for_wrapper="$PRIVATE_IMAGEDIR"
        else
            image_dir_for_wrapper="$PUBLIC_IMAGEDIR"
        fi
        image_name_for_wrapper=$(uri2imgname "$uri") || return 1
    fi

    exec_array=($(parse_exec))
    if [ $? -ne 0 ]; then
        warn -p "Error: No executables are defined for $app"
    fi

    local exec_outdir
    if [[ $personal -eq 1 ]]; then
        exec_outdir="$PRIVATE_EXECUTABLE_DIR"
    else
        exec_outdir="$EXEC_OUTDIR"
    fi

    local AppTool_dir="$exec_outdir/$app/$ver/bin"
    if [[ -d "$AppTool_dir" && $force -eq 0 ]]; then
        warn -p "Output directory $AppTool_dir already exists. Skipping executable generation."
        return 0
    fi

    if [[ -d "$AppTool_dir" && $force -eq 1 ]]; then
        echo "Force option enabled, removing existing directory $AppTool_dir"
        rm -rf "$AppTool_dir" || { echo "Error: Failed to remove directory $AppTool_dir"; exit 1; }
    fi
    mkdir -p "$AppTool_dir" || { warn -p "Error: Failed to create directory $AppTool_dir"; exit 1; }

    if [[ ${#exec_array[@]} -eq 0 ]]; then
        warn -p "Warning: No executables are predefined for $app version $ver."
    else
        echo "Generating executables provided by $app version $ver..."
        for command_exec in "${exec_array[@]}"; do
            # The path passed to confirm_exec_exists must be the reconstructed full path
            if confirm_exec_exists "$command_exec" "$image_dir_for_wrapper/$image_name_for_wrapper"; then
                if generate_executable "$app" "$ver" "$command_exec" "$image_dir_for_wrapper" "$image_name_for_wrapper" "$AppTool_dir"; then
                    echo "Successfully generated: $command_exec"
                else
                    echo "Error: Failed to generate executable: $command_exec" >&2
                fi
            else
                 echo "Warning: Executable not found: $command_exec in $image_dir_for_wrapper/$image_name_for_wrapper" >&2
            fi
        done
    fi
}

confirm_exec_exists() {
    # confirm_exec_exists
    local exec=$1
    local image=$2
    if ! singularity exec "$image" which "$exec" &> /dev/null; then
        echo "Executable '$exec' is NOT installed in the container."
        return 1
    else
        return 0
    fi
}

generate_executable() {
    # generate_executable $app $version $command $image_dir $image_name $AppTool_dir
    local app=$1
    local version=$2
    local command=$3
    local image_dir=$4
    local image_name=$5
    local AppTool_dir=$6
    local executable="$AppTool_dir/$command"

    if [[ -z "$app" || -z "$version" || -z "$command" || -z "$image_dir" || -z "$image_name" || -z "$AppTool_dir" ]]; then
        echo "Error: Missing arguments for generate_executable"
        return 1
    fi

    mkdir -p "$(dirname "$executable")"

    # Generate the bash wrapper script using the IMAGE_DIR and IMAGE variables
    cat <<EOF >"$executable"
#!/usr/bin/env bash

# Set variables
VER="$version"
PKG="$app"
PROGRAM="$command"
IMAGE_DIR="$image_dir"
IMAGE="$image_name"

# Load Singularity if it is not already loaded
if ! command -v singularity &> /dev/null; then
    module load singularity || { echo "Failed to load Singularity module"; exit 1; }
fi

# Determine Nvidia GPUs (to pass the corresponding flag to Singularity)
if nvidia-smi -L &> /dev/null; then
    OPTIONS="--nv"
fi

# Determine AMD GPUs (to pass the corresponding flag to Singularity)
if rocm-smi -L &> /dev/null; then
    OPTIONS="\$OPTIONS --rocm"
fi

# Run the container with appropriate options
singularity exec \$OPTIONS "\$IMAGE_DIR/\$IMAGE" "\$PROGRAM" "\$@"
EOF

    chmod +x "$executable"
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to generate wrapper for $command"
        return 1
    fi
}



###############################################################################
# Functions for extrac basic information and available executables from repo file
###############################################################################

create_appinfo_file() {
    # create_appinfo_file
    local app=$1
    local localappinfo=$2
    echo "$app is not found in our application information database."
    echo "let's create a new entry for $app."
    echo "Enter a simple description of your application (e.g., Blast is an algorithm and program for comparing primary biological sequence information): "
    read description
    echo "Enter the homepage of your application (e.g., https://blast.ncbi.nlm.nih.gov/Blast.cgi):"
    read homepage
    echo "Enter the programs that are available in your application (e.g., blastn, blastp, blastx, tblastn, tblastx):"
    read programs
    mkdir -p "$HOME/container-apps/repos"
    echo "Description: $description" > "$localappinfo"
    echo "Home Page: $homepage" >> "$localappinfo"
    echo "Programs: $programs" >> "$localappinfo"
}

parse_home_description() {
    # parse_home_description
    # Path to the app's file in the repos folder
    if [[ $personal -eq 1 ]]; then
        local app_file="$HOME/container-apps/repos/$app"
    else
        local app_file="$AppInfo_DIR/$app"
    fi

    # It will search the central repo first, then the local copy in the user's $HOME
    APP_INFO_PATH=("$HOME/container-apps/repos" "$AppInfo_DIR")
    for path in "${APP_INFO_PATH[@]}"; do
        if [[ -f "$path/$app" ]]; then
            app_file="$path/$app"
            break
        fi
    done

    # Extract Description and Home Page using grep and sed
    description=$(grep -m1 "^Description:" "$app_file" | sed 's/^Description: //')
    homepage=$(grep -m1 "^Home Page:" "$app_file" | sed 's/^Home Page: //')

    # Check if fields were extracted
    if [[ -z "$description" ]]; then
        echo "Warning: No 'Description' found in $app_file."
    fi
    if [[ -z "$homepage" ]]; then
        echo "Warning: No 'Home Page' found in $app_file."
    fi
}

parse_exec() {
    # parse_exec
    # Path to the app's file in the repos folder
    if [[ $personal -eq 1 ]]; then
        local app_file="$HOME/container-apps/repos/$app"
    else
        local app_file="$AppInfo_DIR/$app"
    fi

    # It will search the central repo first, then the local copy in the user's $HOME
    APP_INFO_PATH=("$HOME/container-apps/repos" "$AppInfo_DIR")
    for path in "${APP_INFO_PATH[@]}"; do
        if [[ -f "$path/$app" ]]; then
            app_file="$path/$app"
            break
        fi
    done

    # Check if the app file exists
    if [[ ! -f "$app_file" ]]; then
        echo "Error: Application file '$app_file' not found."
        return 1   # Exit with a non-zero status if the file doesn't exist
    fi

    # Extract the "Programs" field from the app's file
    executables=$(grep -m1 "^Programs:" "$app_file" | sed 's/^Programs: //')

    # Check if executables are empty
    if [[ -z "$executables" ]]; then
        echo "No executables defined in 'Programs' for $app."
        return 1   # Exit with a non-zero status if 'Programs' is empty
    fi

    # Split the comma-delimited string into an array
    IFS=',' read -r -a arr <<< "$executables"

    # Return the array (if needed for further processing in the calling function)
    echo "${arr[@]}"  # This could be redirected to an array in the calling function
}


###############################################################################
# Functions for creating Jupyter kernels
###############################################################################
jupyter() {
    local uri=$1 # Changed to accept URI
    local app
    app=$(uri2app "$uri") || return 1
    local ver
    ver=$(uri2ver "$uri") || return 1
    local image
    image=$(uri2imgname "$uri") || return 1

    # Define kernel name and directory
    kernel_name="${app}-${ver}"
    if [[ $personal -eq 1 ]]; then
        kernel_dir="$HOME/.local/share/jupyter/kernels/$kernel_name"
    else
        kernel_dir="$JUPYTER_OUTDIR/$kernel_name"
    fi

    # Determine image output directory based on 'personal' flag
    local image_outdir
    if [[ $personal -eq 1 ]]; then
        image_outdir="$PRIVATE_IMAGEDIR"
    else
        image_outdir="$PUBLIC_IMAGEDIR"
    fi

    # Check if the image contains ipykernel
    if ! singularity exec "${image_outdir}/${image}" python -c "import ipykernel" &> /dev/null; then
        MSG=(
            "The required dependency ipykernel is not detected in ${image}."
            ""
            "Please create a new container with ipython and ipykernel."
            ""
            "Update your Dockerfile or Singularity/Apptainer definition file to include:"
            ""
            "   pip install ipython ipykernel"
            )
        boxify_text "${MSG[@]}"
        exit 1
    fi

    # Create the kernel directory and set up kernel.json
    if [[ ! -d "$kernel_dir" ]]; then
        mkdir -p "$kernel_dir"
        cp "$SCRIPT_TOP_DIR/jupyter_kernel.json" "$kernel_dir/kernel.json"

        # Determine executable directory based on 'personal' flag
        local exec_outdir
        if [[ $personal -eq 1 ]]; then
            exec_outdir="${PRIVATE_EXECUTABLE_DIR/#\$HOME/$HOME}"
        else
            exec_outdir="$PUBLIC_EXECUTABLE_DIR"
        fi

        # Define AppTool directory
        local AppTool_dir="$exec_outdir/$app/$ver/bin"

        # Update kernel.json with the correct paths and placeholders
        sed -i -e "s|APPDIR|$AppTool_dir|g" \
               -e "s|APP|$app|g" \
               -e "s|VERSION|$ver|g" \
               "${kernel_dir}/kernel.json"
    else
        echo "Kernel already exists: $kernel_dir"
    fi
    echo "Jupyter kernel created: $kernel_name"
    MSG=(
            "You can now launch Jupyter notebook/lab and select the kernel:"
            ""
            "   $app $ver"
            ""
            "If you'd like to edit the kernel, you can find it at:"
            ""
            "   $kernel_dir"
            ""
        )
        boxify_text "${MSG[@]}"
}


###############################################################################
# Main Script Starts Here
###############################################################################

# Default configuration options
## Flags and options
force=0          # Overwrite modulefile and execs if they exist
personal=0       # Create personal modulefiles in privatemodules (default: false)
jupyter=0        # Create Jupyter kernel for the application (default: false)
LISTPROFILES=0   # List available profiles (default: false)
SCRIPT_TOP_DIR="$(realpath "${BASH_SOURCE[0]}" | xargs dirname)"
TEMPLATE_DIR="$SCRIPT_TOP_DIR/templates"
AppInfo_DIR="${SCRIPT_TOP_DIR}/repos"
PROFILEROOT="${SCRIPT_TOP_DIR}/profiles"
## Output directories
OUTDIR_DEF="."  # Default output directory
OUTDIR="${OUTDIR:-$OUTDIR_DEF}"
IMG_OUTDIR="${OUTDIR}/images"
MOD_OUTDIR="${OUTDIR}/incomplete"
EXEC_OUTDIR="${OUTDIR}/executables"
JUPYTER_OUTDIR="${OUTDIR}/kernels"
PUBLIC_IMAGEDIR="${IMG_OUTDIR}"
## Output directories for personal modules/executables
PRIVATE_EXECUTABLE_DIR="$HOME/container-apps/tools"
PRIVATE_MODULEDIR="$HOME/privatemodules"
PRIVATE_IMAGEDIR="$HOME/container-apps/images"
PROFILEHOMEDIR="$HOME/container-apps/profiles"

# Ensure a subcommand is provided, or display an error and usage instructions
SUBCOMMAND="$1"
if [[ -z "$SUBCOMMAND" ]]; then
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        help_message
        exit 0
    fi
    echo "Error: You must specify a subcommand."
    echo "Usage: ${0##*/} help"
    exit 1
elif [[ "$SUBCOMMAND" == "-h" || "$SUBCOMMAND" == "--help" ]]; then
     help_message
    exit 0
# List available profiles and exit if the -p or --profile flag is set
elif [[ "$SUBCOMMAND" == "-l" || "$SUBCOMMAND" == "--list" ]]; then
    list_profiles
    exit 0
fi

# Skip the first argument (subcommand) for option parsing
shift

declare -a ARGV SING_OPTS  # ARGV stores non-option arguments; SING_OPTS for additional options

###############################################################################
# Command-Line Option Parsing
###############################################################################
while [[ -n "$1" ]]; do
    case $1 in
        --profile)                      # Specify a profile to load
            shift
            PROFILE="$1" ;;
        -d|--dir|--directory)           # Set output directory
            shift
            OUTDIR="$1" ;;
        -f|--force)                     # Enable overwriting of existing files
            force=1 ;;
        -m|--module-dir|--module-directory)
            shift
            MOD_EXISTING_DIR="$1" ;;
        -u|--update)                    # Update the repository
            update_repo=1 ;;
        -h|--help)                      # Display help message
            help_message
            graceful_exit ;;
        -l|--list)                      # List available profiles
            list_profiles
            graceful_exit ;;
        -p|--personal)                  # Enable personal modulefile creation
            personal=1 ;;
        -j|--jupyter)                   # Enable Jupyter kernel creation
            jupyter=1 ;;
        --)                             # End of options
            shift
            break ;;
        -*)                         # Unknown option handling
            echo "Unknown option: $1"
            usage
            exit 1 ;;
        *)                              # Collect non-option arguments
            ARGV+=("$1") ;;
    esac
    shift
done

# Reset positional parameters and count non-option arguments
set -- "${ARGV[@]}"
ARGC=${#ARGV[@]}

###############################################################################
# Profile Loading
###############################################################################
if [[ -n "$PROFILE" ]]; then
    # Check in PROFILEHOMEDIR first
    if [[ -f "${PROFILEHOMEDIR}/$PROFILE" ]]; then
        echo "Loading profile from personal directory: $PROFILE"
        source "${PROFILEHOMEDIR}/$PROFILE"

    # Fallback to PROFILEROOT if not found in PROFILEHOMEDIR
    elif [[ -f "${PROFILEROOT}/$PROFILE" ]]; then
        echo "Loading profile from root directory: $PROFILE"
        source "${PROFILEROOT}/$PROFILE"

    # Error if not found in either directory
    else
        echo "Error: Profile '$PROFILE' not found in either:"
        echo " - $PROFILEHOMEDIR"
        echo " - $PROFILEROOT"
        exit 1
    fi
else
    echo "No profile specified. Running in personal mode!"
    personal=1
fi

MOD_EXISTING_DIR="${MOD_EXISTING_DIR:-$MOD_EXISTING_DIR_DEF}"

###############################################################################
# Initialization
###############################################################################
ensure_appinfo_dir  # Ensure appinfo directory exists

# Populate cache and ensure app files exist for all URIs before processing
for URI in "${ARGV[@]}"; do
    # This call populates the cache. It is NOT in a subshell.
    _ensure_uri_details_cached "$URI" || {
        echo "Error: Could not get application details for URI: $URI" >&2
        exit 1
    }
    # This call can now safely use the cached info.
    ensure_appinfo_file "$URI"
done

# Create required directories
if [[ $personal -eq 1 ]]; then
    create_dir "$PRIVATE_EXECUTABLE_DIR" "Created executable directory"
    create_dir "$PRIVATE_MODULEDIR" "Created module directory"
    create_dir "$PRIVATE_IMAGEDIR" "Created image directory"
else
    create_dir "$EXEC_OUTDIR" "Created executable directory"
    create_dir "$MOD_OUTDIR" "Created module directory"
    create_dir "$IMG_OUTDIR" "Created image directory"
fi

###############################################################################
# Subcommand Handling
###############################################################################
if [ "$SUBCOMMAND" = "pull" ]; then
    handle_subcommand pull "${ARGV[@]}"
elif [ "$SUBCOMMAND" = "module" ]; then
    handle_subcommand module "${ARGV[@]}"
elif [ "$SUBCOMMAND" = "exec" ]; then
    handle_subcommand exec "${ARGV[@]}"
elif [ "$SUBCOMMAND" = "pipe" ]; then
    handle_subcommand pull "${ARGV[@]}"
    handle_subcommand module "${ARGV[@]}"
    handle_subcommand exec "${ARGV[@]}"
elif [ "$SUBCOMMAND" = "help" ]; then
    help_message
    exit 0
else
    echo "Invalid subcommand: $SUBCOMMAND" >&2
    echo "Usage: ${0##*/} help" >&2
    exit 1
fi

###############################################################################
# Module Loading Message (if personal)
###############################################################################
# Check if SUBCOMMAND is either 'module' or 'pipe'
if [[ "$SUBCOMMAND" == "module" || "$SUBCOMMAND" == "pipe" ]]; then

    # Check required environment variables
    if [[ -z "$PRIVATE_MODULEDIR" || -z "$MOD_OUTDIR" ]]; then
        echo "Error: PRIVATE_MODULEDIR or MOD_OUTDIR is not set. Exiting." >&2
        exit 1
    fi

    # Iterate over all URIs provided as arguments
    for URI in "${ARGV[@]}"; do
        # Validate non-empty URI
        if [[ -z "$URI" ]]; then
            echo "Error: Empty URI encountered in arguments. Skipping." >&2
            continue
        fi

        # Extract app, version, and module name
        app=$(uri2app "$URI") || continue
        ver=$(uri2ver "$URI") || continue
        modname=$(uri2modname "$URI") || continue


        # Validate modname resolution
        if [[ -z "$modname" ]]; then
            echo "Error: Failed to resolve module name for URI: $URI. Skipping." >&2
            continue
        fi

        # Determine message based on personal vs. shared environment
        if [[ $personal -eq 1 ]]; then
            MSG=(
                "To use this module, load the following modules:"
                ""
                "    module load use.own"
                "    module load $app/$ver"
                ""
                "The modulefile is located at: $PRIVATE_MODULEDIR/$modname"
            )
        else
            MSG=(
                "To use this module, load the following modules:"
                ""
                "    module use $MOD_OUTDIR"
                "    module load $app/$ver"
                ""
                "The modulefile is located at: $MOD_OUTDIR/$modname"
            )
        fi

        # Display the message in a boxed format
        boxify_text "${MSG[@]}"
    done
fi

###############################################################################
# Jupyter Kernel Creation
###############################################################################
if [[ $jupyter -eq 1 ]]; then
    for URI in "${ARGV[@]}"; do
        echo "Generating Jupyter kernel for $URI"
        if ! jupyter "$URI"; then # Pass the whole URI
            echo "Error: Failed to create Jupyter kernel for $URI" >&2
        fi
    done
fi