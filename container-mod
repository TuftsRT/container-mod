#!/bin/bash

# Yucheng Zhang

# Copyright (c) 2024 Tufts University
# This script is modified from the original script written by Lev Gorenstein from Purdue University.
# The original script is available at (https://github.com/PurdueRCAC/Biocontainers).

# This script assumes that you have Singularity or Apptainer
# installed on your system.
#
# Usage: Run "container-mod --help" for instructions.
VERSION="0.1.2" # Increment this version for updates

###############################################################################
# Prerequisites: Ensure Singularity or Apptainer is available
###############################################################################

if ! command -v singularity > /dev/null 2>&1; then
    if module load singularity 2>/dev/null; then
        :
    else
        if module load apptainer 2>/dev/null; then
            :
        else
            echo "Failed to load both Singularity and Apptainer modules."
            exit 1
        fi
    fi
fi

###############################################################################
# Helper functions
###############################################################################

# --- Caches for app name and version to avoid repeated prompting ---
declare -A APP_CACHE
declare -A VER_CACHE

clean_up() {
	# Perform pre-exit housekeeping
	return
}

# Function to print a message and exit with a status
graceful_exit() {
	# graceful_exit [status]]
	clean_up
	exit ${1:-$E_OK}
}

# Function to send warning messages to stderr.
warn() {
    # warn [-p] "message" ["message"...]
    # Sends message(s) to stderr, optionally prefixing with "PROGNAME: ".
    local msg
    local withname=0
    local opt OPTIND

    while getopts :p opt; do
        case $opt in
            p) withname=1 ;;
        esac
    done
    shift $((OPTIND - 1)) # Shift away the processed options

    # Output messages
    for msg in "$@" ; do
        if [[ $withname -ne 0 ]]; then
            msg="$PROGNAME: $msg"
        fi
        echo -e "$msg" 1>&2
    done
}

# Prompts user for app name and version for a local file and caches the result.
# This internal function is called by _ensure_uri_details_cached.
_prompt_for_local_details() {
    local uri="$1"
    # If already cached, do nothing.
    if [[ -v "APP_CACHE[$uri]" ]]; then
        return 0
    fi

    # Redirect this informational message to stderr to prevent command substitution capture.
    echo "Local image file detected: $uri" >&2

    local app version
    read -r -p "-> Enter the application name: " app
    if [[ -z "$app" ]]; then
        echo "Error: Application name cannot be empty." >&2
        return 1
    fi

    read -r -p "-> Enter the application version: " version
    if [[ -z "$version" ]]; then
        echo "Error: Version cannot be empty." >&2
        return 1
    fi

    APP_CACHE["$uri"]="$app"
    VER_CACHE["$uri"]="$version"
    return 0
}

# Populates the APP_CACHE and VER_CACHE for a given URI.
# This function is called directly to ensure it can modify the global cache arrays
# without being affected by subshells from command substitution.
_ensure_uri_details_cached() {
    local uri="$1"
    # If already cached, do nothing.
    if [[ -v "APP_CACHE[$uri]" ]]; then
        return 0
    fi

    local app ver

    # If it's a local file, prompt the user for details.
    if [[ -f "$uri" ]]; then
        # This call to the prompter is now safe because this parent
        # function is not called with command substitution.
        _prompt_for_local_details "$uri" || return 1
        return 0 # The cache is now populated.
    fi

    # --- If it's a remote URI, parse it and populate the cache ---

    # App parsing logic (from the old uri2app)
	if [[ "$uri" == */qiime2/core:* ]]; then
		app="qiime2"
	elif [[ "$uri" == */r-base:* ]]; then
		app="r"
	elif [[ "$uri" == */cumulusprod_cellranger:* ]]; then
		app="cellranger"
	elif [[ "$uri" == */nvidia/clara/clara-parabricks:* ]]; then
		app="parabricks"
    elif [[ "$uri" == */nvidia/devtools/nsight-systems-cli:* ]]; then
        app="nsightsys"
	else
		app="${uri##*/}"
		app=${app%%:*}
	fi

    # Version parsing logic (from the old uri2ver)
	ver="${uri##*/}"
	ver=${ver##*:}
	ver=$(echo "$ver" | sed -re 's/(--.*)?(_[0-9]+)?$//')

    # Populate the cache for the remote URI
    APP_CACHE["$uri"]="$app"
    VER_CACHE["$uri"]="$ver"
    return 0
}


# Function to display the help message
help_message() {
    scriptname="container-mod"
    cat <<-EOF

${scriptname} v$VERSION - Container Module Generator

This script streamlines the process of pulling container images from public registries,
and automates the generation of module files and wrapper scripts,
enabling users to seamlessly run containers as if they were standard software modules.
Usage:
    ${scriptname} <subcommand> [options] <URIs>

Subcommands:
    pull        Pull the container image from the specified URIs.
    module      Generate module files for the specified URIs.
    exec        Generate wrapper scripts for the programs provided by the container.
    pipe        Pull, generate module files, and generate wrapper scripts for the specified URIs.
Options:
  -d, --dir DIR           Specify the output directory for images and module files (default is the current directory).
  -f, --force             Force overwrite of existing images and module files (default behavior is to skip).
  -m, --moduledir DIR     Specify the directory for storing generated module files.
  -u, --update            Update the app file in the repos directory with the new version (default is no).
  -p, --personal          Create personal module files in the privatemodules directory (default is no).
  --profile               Use the specified profile for configuration.
Available profiles are stored in profiles directory.
  -j, --jupyter           Generate Jupyter kernels for the specified URIs.
  -h, --help              Display this help message and exit.
Examples:
    ${scriptname} pull docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} module docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} exec docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} pipe -p docker://quay.io/biocontainers/vcftools:0.1.16
    ${scriptname} pipe --profile biocontainer docker://quay.io/biocontainers/vcftools:0.1.16

EOF
}

list_profiles() {
    # List available profiles
    if [ -d "${PROFILEHOMEDIR}" ]; then
        for PROFILE in "${PROFILEHOMEDIR}"/*; do
            PROFILENAME="$(basename "${PROFILE}")"
            if [ "${PROFILENAME}" != "*" ]; then
                echo "${PROFILENAME}  (Personal Profile)"
            fi
        done
    fi
    if [ -d "${PROFILEROOT}" ]; then
        for PROFILE in "${PROFILEROOT}"/*; do
            PROFILENAME="$(basename "${PROFILE}")"
            if [ "${PROFILENAME}" != "*" ]; then
                if [ -e "${PROFILEHOMEDIR}/${PROFILENAME}" ]; then
                    echo "${PROFILENAME}  (Overridden)"
                else
                    echo "${PROFILENAME}"
                fi
            fi
        done
    fi
    exit 0
}

boxify_text()
{
	#
	# Usage: boxify_text AAAA [BBB ...]
	#
	# Output:
	#	+------+
	#	| AAAA |
	#	| BBB  |
	#	+------+
	#
	local msg=("$@")
	local line longest width
	for line in "${msg[@]}"; do
		if [[ ${#line} -gt $width ]]; then
			longest="$line"
			width="${#line}"
		fi
	done
	echo "+-${longest//?/-}-+"
	for line in "${msg[@]}"; do
		printf '| %s%*s%s |\n' "$(tput bold)" "-$width" "$line" "$(tput sgr0)"
	done
	echo "+-${longest//?/-}-+"
}

# Create directory if it doesn't exist
create_dir() {
    local dir_path="$1"
    local message="$2"
    if [[ ! -d "$dir_path" ]]; then
        mkdir -p "$dir_path"
        echo "$message: $dir_path"
    fi
}

# Process a list of URIs with a given command
handle_subcommand() {
    local cmd="$1"
    shift

    for URI in "$@"; do
        echo "Processing URI: $URI with the subcommand: $cmd"
        if ! "$cmd" "$URI"; then
            echo "Error executing command '$cmd' for URI: $URI" >&2
            exit 1 # Halt on the first failure
        fi
    done
    return 0 # All commands succeeded
}

# Copy the AppInfo directory if missing
ensure_appinfo_dir() {
    # Ensure the personal mode is enabled and the target directory doesn't exist
    if [[ "$personal" -eq 1 && ! -d "$HOME/container-apps/repos" ]]; then
        # Create the directory if it doesn't exist
        mkdir -p "$HOME/container-apps" || {
            echo "Error: Failed to create directory $HOME/container-apps" >&2
            return 1
        }

        # Copy the AppInfo directory
        if [[ -d "$AppInfo_DIR" ]]; then
            cp -r "$AppInfo_DIR" "$HOME/container-apps/" || {
                echo "Error: Failed to copy $AppInfo_DIR to $HOME/container-apps/" >&2
                return 1
            }
        else
            echo "Error: Source directory $AppInfo_DIR does not exist" >&2
            return 1
        fi
    fi
}

# Ensure app info file exists
ensure_appinfo_file() {
    local URI="$1"

    # Validate input argument
    if [[ -z "$URI" ]]; then
        echo "Error: URI parameter is missing." >&2
        return 1
    fi

    local app
    app=$(uri2app "$URI") || {
        echo "Error: Failed to extract app name from URI: $URI" >&2
        return 1
    }

    # Determine the target path for the appinfo file
    local target_path
    echo "Checking existence of files for $app"
    echo "$HOME/container-apps/repos/$app exists? $(test -f "$HOME/container-apps/repos/$app" && echo yes || echo no)"
    echo "$AppInfo_DIR/$app exists? $(test -f "$AppInfo_DIR/$app" && echo yes || echo no)"

    if [[ ! -f "$HOME/container-apps/repos/$app" && ! -f "$AppInfo_DIR/$app" ]]; then
    	if [[ "$personal" -eq 1 ]]; then
        	target_path="$HOME/container-apps/repos/$app"
    	else
        	target_path="$AppInfo_DIR/$app"
    	fi
    	echo "Debug: target_path is set to $target